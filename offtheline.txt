{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "        <center>\n        <div id=\"game\">\n        </div>\n        </center>",
      "status": "",
      "output": "        <center>\n        <div id=\"game\">\n        <canvas width=\"640\" height=\"480\" style=\"width: 640px; height: 480px; background-color: black;\"></canvas></div>\n        </center>",
      "type": "html"
    },
    {
      "code": "// From book: Real Time Collision Detection - Christer Ericson\nfunction signed2DTriArea(ax, ay, bx, by, cx, cy)\n{\n    return (ax - cx)*(by - cy) - (ay - cy)*(bx - cx);\n}\n\n// From book: Real Time Collision Detection - Christer Ericson\nfunction getLineIntersectionInfo(ax, ay, bx, by, cx, cy, dx, dy)\n{\n    let info = {intersect:false};\n\n    let a1 = signed2DTriArea(ax, ay, bx, by, dx, dy);\n    let a2 = signed2DTriArea(ax, ay, bx, by, cx, cy);\n    if (a1*a2 < 0.0)\n    {\n        let a3 = signed2DTriArea(cx, cy, dx, dy, ax, ay);\n        let a4 = a3 + a2 - a1;\n        if (a3*a4 < 0.0)\n        {\n            info.time = a3 / (a3 - a4);\n            info.x = ax + info.time*(bx - ax);\n            info.y = ay + info.time*(by - ay);\n            info.intersect = true;\n        }\n    }\n\n    return info;\n}\n\n// From book: Real Time Collision Detection - Christer Ericson\nfunction sqDistanceToLine(ax, ay, bx, by, cx, cy)\n{\n    let ab = {x:bx - ax, y:by - ay};\n    let ac = {x:cx - ax, y:cy - ay};\n    let bc = {x:cx - bx, y:cy - by};\n\n    // Handle cases where c projects outside of ab\n    let e = dot(ac, ab);\n    if (e <= 0.0)\n    {\n        return dot(ac, ac);\n    }\n\n    let f = dot(ab, ab);\n    if (e >= f)\n    {\n        return dot(bc, bc);\n    }\n\n    // Handle cases where c projects onto ab\n    return dot(ac, ac) - e * e / f;\n}\n\nfunction dot(v1, v2)\n{\n    return v1.x*v2.x + v1.y*v2.y;\n}\nfunction getBest()\n{\n   return 0;\n}\n\nfunction setBest()\n{\n   \n}\n\nfunction getDifficultyModeName()\n{\n    let modeName = \"EASY MODE\";\n    if (difficultyMode === 1)\n    {\n        modeName = \"HARD MODE\"\n    }\n    else if (difficultyMode === 2)\n    {\n        modeName = \"ULTRA MEGA MODE\";\n    }\n\n    return modeName;\n}\nfunction resetCamera()\n{\n    aw.ctx.setTransform(1, 0, 0, 1, 0, 0);\n}\n\nfunction setLevelCamera()\n{\n    aw.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    aw.ctx.translate(screenWidth*0.5, screenHeight*0.5);\n    aw.ctx.translate(-shakeAmountCur + shakeAmountCur*Math.random()*2, -shakeAmountCur + shakeAmountCur*Math.random()*2);\n    aw.ctx.scale(levelPopScaleAmountCur, -levelPopScaleAmountCur);\n}\n\nvar shakeAmountCur = 0;\nvar shakeAmountMax = 0;\nvar shakeTimeCur = 0;\nvar shakeTimeMax = 0;\nfunction startCameraShake(amount, time)\n{\n    shakeAmountMax = amount;\n    shakeAmountCur = amount;\n    shakeTimeMax = time;\n    shakeTimeCur = time;\n}\n\nfunction updateCameraShake(deltaTime)\n{\n    if (shakeTimeCur > 0)\n    {\n        shakeTimeCur -= deltaTime;\n        shakeAmountCur = Math.max((shakeTimeCur / shakeTimeMax) * shakeAmountMax, 0);\n    }\n}\n\nvar levelPopScaleAmountMax = 0.15;\nvar levelPopScaleAmountCur = 1.0;\nvar levelPopScaleTimeMax = 0.2;\nvar levelPopScaleTimeCur = 0;\nfunction startLevelScalePop()\n{\n    levelPopScaleAmountCur = 1.0 + levelPopScaleAmountMax;\n    levelPopScaleTimeCur = levelPopScaleTimeMax;\n    updateLevelScalePop(0.0);\n}\n\nfunction updateLevelScalePop(deltaTime)\n{\n    if (levelPopScaleTimeCur > 0)\n    {\n        levelPopScaleTimeCur -= deltaTime;\n        let pct = levelPopScaleTimeCur / levelPopScaleTimeMax;\n        pct = pct*pct*pct;\n        levelPopScaleAmountCur = Math.max(1.0 + pct * levelPopScaleAmountMax, 1.0);\n    }\n}\nvar deathParticles = [];\n\nfunction particleUpdate(deltaTime)\n{\n    deathParticles.forEach((particle, idx) =>\n    {\n        let lifePct = particle.timeLeft / 0.5;\n        let lifePctSmoothed = 1.0 - (lifePct*lifePct*lifePct);\n        let x = particle.x + Math.cos(particle.moveAngle)*particle.maxRadius*lifePctSmoothed;\n        let y = particle.y + Math.sin(particle.moveAngle)*particle.maxRadius*lifePctSmoothed;\n        let angle = particle.angle + Math.PI*1.0*lifePctSmoothed;\n        if (idx % 2 == 0)\n        {\n            angle = -angle;\n        }\n\n        aw.ctx.globalAlpha = lifePct < 0.25 ? lifePct / 0.25 : 1.0;\n        aw.ctx.save();\n        aw.ctx.translate(x, y);\n        aw.ctx.rotate(angle);\n        let lineWidthSave = aw.ctx.lineWidth;\n        aw.ctx.lineWidth = 4;\n        aw.ctx.strokeStyle = \"#08F\";\n        aw.ctx.shadowColor = \"#08F\";\n        aw.ctx.beginPath();\n        aw.ctx.moveTo(-6.0, 0.0);\n        aw.ctx.lineTo(6.0, 0.0);\n        aw.ctx.stroke();\n        aw.ctx.restore();\n        aw.ctx.lineWidth = lineWidthSave;\n        aw.ctx.globalAlpha = 1.0;\n\n        particle.timeLeft -= deltaTime;\n        if (particle.timeLeft <= 0.0)\n        {\n            particle._remove = true;\n        }\n    });\n\n    deathParticles = deathParticles.filter(particle => particle._remove !== true);\n}\n\nfunction addDeathParticle(x, y)\n{\n    for (let i = 0; i < 10; i++)\n    {\n        deathParticles.push({x:x, y:y, timeLeft:0.5, _remove:false, angle:Math.random()*Math.PI*2, moveAngle:(Math.random()*360)*Math.PI/180, maxRadius:15 + Math.random()*40});\n    }\n}\nclass Player\n{\n    constructor()\n    {\n        this.x = 0;\n        this.y = 0;\n        this.xPrev = 0;\n        this.yPrev = 0;\n        this.xPrev2 = 0;\n        this.yPrev2 = 0;\n        this.boxSize = 12;\n        this.speed = difficultyMode === 0 ? 250 : 400;\n        this.maxButtonClickLookBackTime = 0.2;\n        this.lastLeftButtonClickedDeltaTime = Number.MAX_SAFE_INTEGER;\n        this.curLineDist = 0;\n        this.curLevelGroup = 0;\n        this.curState = this.onLineUpdate;\n        this.jumpVel = {x:0, y:0};\n        this.jumpSpeed = 1500;\n        this.isJumping = false;\n        this.isDead = false;\n        this.angle = 0;\n        this.rotSpeed = 180;\n        this.xLineDir = 0;\n        this.yLineDir = 0;\n\n        let posInfo = level.getPosInfo(this.curLevelGroup, this.curLineDist);\n        this.x = posInfo.x;\n        this.y = posInfo.y;\n        this.xPrev2 = this.x;\n        this.yPrev2 = this.y;\n        this.xPrev = this.x;\n        this.yPrev = this.y;\n        this.xJump = this.x;\n        this.yJump = this.y;\n    }\n\n    update(deltaTime)\n    {\n        this.xPrev2 = this.xPrev;\n        this.yPrev2 = this.yPrev;\n        this.xPrev = this.x;\n        this.yPrev = this.y;\n\n        this.angle += this.rotSpeed*deltaTime;\n\n        if (this.curState !== undefined)\n        {\n            this.curState(deltaTime);\n        }\n    }\n\n    onLineUpdate(deltaTime)\n    {\n        this.curLineDist += this.speed*deltaTime;\n        if (this.curLineDist < 0.0)\n        {\n            this.curLineDist += level.totalDistance[this.curLevelGroup];\n        }\n        this.curLineDist = (this.curLineDist % level.totalDistance[this.curLevelGroup]);\n        let posInfo = level.getPosInfo(this.curLevelGroup, this.curLineDist);\n        this.x = posInfo.x;\n        this.y = posInfo.y;\n        this.xLineDir = posInfo.xDir;\n        this.yLineDir = posInfo.yDir;\n\n        // Check for death\n        aw.entities.forEach(entity =>\n        {\n            if (entity instanceof Wall)\n            {\n                let lineIntersectInfo = getLineIntersectionInfo(this.xPrev2, this.yPrev2, this.x, this.y, entity.x1, entity.y1, entity.x2, entity.y2);\n                if (lineIntersectInfo.intersect)\n                {\n                    addDeathParticle(lineIntersectInfo.x, lineIntersectInfo.y);\n                    this.hit();\n                }\n            }\n        });\n\n        if (!this.isDead)\n        {\n            this.lastLeftButtonClickedDeltaTime += deltaTime;\n            if (aw.mouseLeftButtonJustPressed || aw.keysJustPressed[\"space\"])\n            {\n                this.lastLeftButtonClickedDeltaTime = 0;\n            }\n\n            if (this.lastLeftButtonClickedDeltaTime <= this.maxButtonClickLookBackTime)\n            {\n                this.jumpVel = {x:posInfo.nx * this.jumpSpeed, y:posInfo.ny * this.jumpSpeed};\n                this.xJump = this.x;\n                this.yJump = this.y;\n\n                this.isJumping = true;\n                this.curState = this.jumpingUpdate;\n\n                aw.playNote(\"a\", 5, 0.01);\n                aw.playNote(\"a#\", 5, 0.01, 0.01);\n                aw.playNote(\"b\", 5, 0.01, 0.02);\n            }\n        }\n    }\n\n    jumpingUpdate(deltaTime)\n    {\n        this.x += this.jumpVel.x * deltaTime;\n        this.y += this.jumpVel.y * deltaTime;\n\n        // Check for death\n        aw.entities.forEach(entity =>\n        {\n            if (entity instanceof Wall)\n            {\n                let lineIntersectInfo = getLineIntersectionInfo(this.xPrev2, this.yPrev2, this.x, this.y, entity.x1, entity.y1, entity.x2, entity.y2);\n                if (lineIntersectInfo.intersect)\n                {\n                    addDeathParticle(lineIntersectInfo.x, lineIntersectInfo.y);\n                    this.hit();\n                }\n            }\n        });\n        \n        // Off screen?\n        if (this.x < -screenWidth*0.5 - this.boxSize || this.x > screenWidth*0.5 + this.boxSize ||\n            this.y < -screenHeight*0.5 - this.boxSize || this.y > screenHeight*0.5 + this.boxSize)\n        {\n            this.hit();\n        }\n\n        if (!this.isDead)\n        {\n            // Check for hitting coins\n            aw.entities.forEach(entity =>\n            {\n                if (entity instanceof Coin)\n                {\n                    let distToPlayer = sqDistanceToLine(this.xPrev, this.yPrev, this.x, this.y, entity.x, entity.y);\n                    if (distToPlayer <= entity.hitSizeSq)\n                    {\n                        entity.hit();\n                    }\n                }\n            });\n\n            // Check for hitting level again\n            let intersectInfo = level.getIntersectionInfo(this.xPrev, this.yPrev, this.x, this.y);\n            if (intersectInfo.intersect)\n            {\n                let xDist = intersectInfo.x - this.xJump;\n                let yDist = intersectInfo.y - this.yJump;\n                let sqDist = xDist*xDist + yDist*yDist;\n                if (sqDist > 5.0)\n                {\n                    this.curLineDist = intersectInfo.distance;\n                    this.curLevelGroup = intersectInfo.group;\n                    let posInfo = level.getPosInfo(this.curLevelGroup, this.curLineDist);\n                    this.x = posInfo.x;\n                    this.y = posInfo.y;\n                    this.lastLeftButtonClickedDeltaTime = Number.MAX_SAFE_INTEGER;\n\n                    this.isJumping = false;\n                    this.curState = this.onLineUpdate;\n\n                    // Change direction if the line we jumped to is in the opposite direction\n                    // compared to the line we jumped from. This makes the player keep going\n                    // in the same direction that you were previously going.\n                    let dot = posInfo.xDir*this.xLineDir + posInfo.yDir*this.yLineDir;\n                    if (dot < 0.0)\n                    {\n                        this.speed = -this.speed;\n                    }\n\n                    startCameraShake(2.5, 0.15);\n\n                    aw.playNote(\"a\", 4, 0.01);\n                    aw.playNote(\"a#\", 4, 0.01, 0.01);\n                }\n            }\n        }\n    }\n\n    deadUpdate()\n    {\n\n    }\n\n    render()\n    {\n        if (!this.isDead)\n        {\n            aw.ctx.save();\n            aw.ctx.translate(this.x, this.y);\n            aw.ctx.rotate(this.angle);\n            let lineWidthSave = aw.ctx.lineWidth;\n            aw.ctx.lineWidth = 4;\n            aw.ctx.strokeStyle = \"#08F\";\n            aw.ctx.shadowColor = \"#08F\";\n            aw.ctx.beginPath();\n            aw.ctx.rect(-this.boxSize*0.5, -this.boxSize*0.5, this.boxSize, this.boxSize);\n            aw.ctx.stroke();\n            aw.ctx.restore();\n            aw.ctx.lineWidth = lineWidthSave;\n        }\n    }\n\n    hit()\n    {\n        lives = Math.max(lives - 1, 0);\n        this.isDead = true;\n        this.curState = this.deadUpdate;\n\n        startCameraShake(5, 0.2);\n        aw.playNote(\"a\", 1, 0.2, 0.0, \"square\");\n        aw.playNoise(0.05);\n    }\n}\nclass Coin\n{\n    constructor(x, y, offset, offsetAngle, offsetRotSpeed)\n    {\n        this.xCenter = x;\n        this.yCenter = y;\n        this.x = x;\n        this.y = y;\n        this.boxSize = 8;\n        this.hitSize = 20;\n        this.hitSizeSq = this.hitSize * this.hitSize;\n        this.angle = 0;\n        this.rotSpeed = 180;\n        this.active = true;\n        this.offset = offset !== undefined ? offset : 0;\n        this.offsetAngle = offsetAngle !== undefined ? (offsetAngle * Math.PI/180) : 0;\n        this.offsetRotSpeed = offsetRotSpeed !== undefined ? (offsetRotSpeed * Math.PI/180) : 0;\n        this.deathTimeCur = 0.0;\n        this.deathTimeMax = 0.5;\n    }\n\n    update(deltaTime)\n    {\n        this.angle -= this.rotSpeed*deltaTime;\n\n        if (this.offset !== 0)\n        {\n            let xOffset = Math.cos(this.offsetAngle);\n            let yOffset = Math.sin(this.offsetAngle);\n            this.x = this.xCenter + xOffset*this.offset;\n            this.y = this.yCenter + yOffset*this.offset;\n\n            if (this.offsetRotSpeed !== 0)\n            {\n                this.offsetAngle += this.offsetRotSpeed*deltaTime;\n            }\n        }\n\n        if (!this.active)\n        {\n            this.deathTimeCur += deltaTime;\n        }\n    }\n\n    render()\n    {\n        if (this.active || this.deathTimeCur < this.deathTimeMax)\n        {\n            let alphaSave = aw.ctx.globalAlpha;\n\n            let scale = 1.0;\n            if (!this.active)\n            {\n                let deathPct = 1.0 - (this.deathTimeCur / this.deathTimeMax);\n                deathPct = deathPct*deathPct*deathPct*deathPct*deathPct;\n                scale += (1.0 - deathPct)*3.0;\n                aw.ctx.globalAlpha = deathPct;\n            }\n\n            aw.ctx.save();\n            aw.ctx.translate(this.x, this.y);\n            aw.ctx.rotate(this.angle * Math.PI/180);\n            aw.ctx.scale(scale, scale);\n            aw.ctx.lineWidth = 2;\n            aw.ctx.strokeStyle = \"#FF0\";\n            aw.ctx.shadowColor = \"#FF0\";\n            aw.ctx.beginPath();\n            aw.ctx.rect(-this.boxSize*0.5, -this.boxSize*0.5, this.boxSize, this.boxSize);\n            aw.ctx.stroke();\n            aw.ctx.restore();\n\n            aw.ctx.globalAlpha = alphaSave;\n        }\n    }\n\n    hit()\n    {\n        if (this.active)\n        {\n            this.active = false;\n            aw.playNote(\"g\", 7, 0.025);\n        }\n    }\n}\nclass Wall\n{\n    constructor(x, y, length, angle, rotSpeed, xMove, yMove, moveTime, idleTime)\n    {\n        this.xCenter = x;\n        this.yCenter = y;\n        this.length = length;\n        this.halfLength = length * 0.5;\n        this.angle = angle !== undefined ? angle * Math.PI/180 : 0;\n        this.rotSpeed = rotSpeed !== undefined ? rotSpeed * Math.PI/180 : 0;\n        this.xMove = xMove !== undefined ? xMove : 0;\n        this.yMove = yMove !== undefined ? yMove : 0;\n        this.moveTime = moveTime !== undefined ? moveTime : 0;\n        this.idleTime = idleTime !== undefined ? idleTime : 0;\n        this.curTimer = this.moveTime;\n        this.isMoving = true;\n        this.moveForward = true;\n        this.curMovePct = 0.0;\n\n        this.updateEndPoints();\n    }\n\n    update(deltaTime)\n    {\n        let changed = false;\n\n        if (this.rotSpeed !== 0)\n        {\n            this.angle += this.rotSpeed*deltaTime;\n            changed = true;\n        }\n\n        if ((this.xMove !== 0 || this.yMove !== 0) && this.moveTime !== 0)\n        {\n            if (this.isMoving)\n            {\n                this.curMovePct = this.moveForward ? 1.0 - (this.curTimer / this.moveTime) : this.curTimer / this.moveTime;\n            }\n            else\n            {\n                this.curMovePct = this.moveForward ? 0.0 : 1.0;\n            }\n\n            this.curTimer -= deltaTime;\n            if (this.curTimer <= 0.0)\n            {\n                if (this.isMoving)\n                {                    \n                    this.curTimer = this.idleTime;\n                    this.moveForward = !this.moveForward;\n                }\n                else\n                {\n                    this.curTimer = this.moveTime;\n                }\n                this.isMoving = !this.isMoving;\n            }\n\n            changed = true;\n        }\n\n        if (changed)\n        {\n            this.updateEndPoints();\n        }\n    }\n\n    updateEndPoints()\n    {\n        let xDir = Math.cos(this.angle);\n        let yDir = Math.sin(this.angle);\n\n        let xCenterCur = this.xCenter + this.xMove*this.curMovePct;\n        let yCenterCur = this.yCenter + this.yMove*this.curMovePct;\n\n        this.x1 = xCenterCur - xDir*this.halfLength;\n        this.y1 = yCenterCur - yDir*this.halfLength;\n        this.x2 = xCenterCur + xDir*this.halfLength;\n        this.y2 = yCenterCur + yDir*this.halfLength;\n    }\n\n    render()\n    {\n        aw.ctx.save();\n        aw.ctx.lineWidth = 2;\n        aw.ctx.strokeStyle = \"#F00\";\n        aw.ctx.shadowColor = \"#F00\";\n        aw.ctx.beginPath();\n        aw.ctx.moveTo(this.x1, this.y1);\n        aw.ctx.lineTo(this.x2, this.y2);\n        aw.ctx.stroke();\n        aw.ctx.restore();\n    }\n}\nfunction drawUI(deltaTime)\n{\n    particleUpdate(deltaTime);\n\n    resetCamera();\n\n    // Timer\n    if (difficultyMode == 2)\n    {\n        let xStart = 10;\n        let yStart = screenHeight - 30;\n        aw.ctx.fillStyle = \"#FFF\";\n        aw.ctx.fillRect(xStart, yStart, (level.timer / level.levelTime)*(screenWidth - 20), 20);\n    }\n\n    // Level #\n    aw.ctx.shadowColor = \"#FFF\";\n    aw.drawText({text:`LEVEL ${(levelIdx + 1)} - ${level ? level.name : \"\"}`, x:10, y:30, fontSize:24, fontStyle:\"bold\"});\n    aw.drawText({text:`BEST: ${getBest() + 1}`, x:10, y:50, fontSize:15, fontStyle:\"bold\", color:\"#FFF\"});\n\n    // Lives\n    if (difficultyMode === 2)\n    {\n        aw.ctx.shadowColor = \"#08F\";\n        aw.drawText({text:\"UNLIMITED LIVES\", x:630, y:25, fontSize:15, fontStyle:\"bold\", color:\"#08F\", textAlign:\"right\"});\n        aw.drawText({text:\"PRESS [ESC] TO QUIT\", x:630, y:45, fontSize:15, fontStyle:\"bold\", color:\"#08F\", textAlign:\"right\"});\n    }\n    else\n    {\n        let numLives = difficultyMode === 0 ? 10 : 5;\n        let xStart = difficultyMode === 0 ? 440 : 536;\n        for (let i = 0; i < numLives; i++)\n        {\n            if (i < lives)\n            {\n                aw.ctx.lineWidth = 3;\n                aw.ctx.strokeStyle = \"#08F\";\n                aw.ctx.shadowColor = \"#08F\";\n                aw.ctx.save();\n                aw.ctx.translate(xStart + 4 + i*20, 18);\n                aw.ctx.beginPath();\n                let boxSize = 10;\n                aw.ctx.rect(-boxSize*0.5, -boxSize*0.5, boxSize, boxSize);\n                aw.ctx.stroke();\n                aw.ctx.restore();\n            }\n            else\n            {\n                aw.ctx.shadowColor = \"#F00\";\n                aw.drawText({text:\"x\", x:xStart + i*19.6, y:30, fontSize:24, fontStyle:\"bold\", color:\"#F00\"});\n            }\n        }\n    }\n\n    // Game over\n    if (aw.state === gameOver)\n    {\n        if (levelIdx === 19)\n        {\n            aw.ctx.shadowColor = \"#555\";\n            aw.ctx.fillStyle = \"#555\";\n            aw.ctx.fillRect(0, 100, screenWidth, 110);\n\n            let flashColor = Date.now() % 500 < 250 ? \"#08F\" : \"#FF0\";\n            aw.ctx.shadowColor = flashColor;\n            aw.drawText({text:\"CONGRATULATIONS!\", x:screenWidth*0.5, y:150, fontSize:40, fontStyle:\"bold\", color:flashColor, textAlign:\"center\"});\n\n            aw.ctx.shadowColor = \"#FFF\";\n            aw.drawText({text:`${getDifficultyModeName()} COMPLETE`, x:screenWidth*0.5, y:180, fontSize:20, fontStyle:\"bold\", color:\"#FFF\", textAlign:\"center\"});\n            aw.drawText({text:\"CLICK TO QUIT TO MAIN MENU\", x:screenWidth*0.5, y:200, fontSize:14, fontStyle:\"bold\", color:\"#FFF\", textAlign:\"center\"});\n        }\n        else\n        {\n            aw.ctx.shadowColor = \"#333\";\n            aw.ctx.fillStyle = \"#333\";\n            aw.ctx.fillRect(0, 52, screenWidth, 140);\n\n            aw.ctx.shadowColor = \"#F00\";\n            aw.drawText({text:\"GAME OVER\", x:screenWidth*0.5, y:100, fontSize:40, fontStyle:\"bold\", color:\"#F00\", textAlign:\"center\"});\n\n            aw.ctx.shadowColor = \"#FFF\";\n            aw.drawText({text:getDifficultyModeName(), x:screenWidth*0.5, y:100 + 30, fontSize:20, fontStyle:\"bold\", color:\"#FFF\", textAlign:\"center\"});\n            aw.drawText({text:`SCORE: ${levelIdx + 1}`, x:screenWidth*0.5, y:100 + 55, fontSize:20, fontStyle:\"bold\", color:\"#FFF\", textAlign:\"center\"});\n            aw.drawText({text:`BEST: ${getBest() + 1}`, x:screenWidth*0.5, y:100 + 80, fontSize:20, fontStyle:\"bold\", color:\"#FFF\", textAlign:\"center\"});\n        }\n    }\n}\nvar menuOptions =\n[\n    {text:\"EASY MODE\", width:255, helpText:\"(SLOW SPEED + 10 LIVES)\"},\n    {text:\"HARD MODE\", width:260, helpText:\"(FAST SPEED + 5 LIVES)\"},\n    {text:\"ULTRA MEGA MODE\", width:388, helpText:\"(FAST SPEED + TIMED LEVELS)\"}\n];\n\nvar prevOption = -1;\nfunction mainMenu(deltaTime)\n{\n    renderBackgroundSpeedLines(deltaTime);\n\n    aw.ctx.save();\n    resetCamera();\n\n    aw.ctx.shadowColor = \"#08F\";\n    aw.drawText({text:\"OFF THE LINE\", x:15, y:10, fontSize:70, fontStyle:\"bold italic\", color:\"#08F\", textAlign:\"left\", textBaseline:\"top\"});\n\n    aw.ctx.shadowColor = \"#08F\";\n    // aw.drawText({text:\"A GAME BY BRYAN PERFETTO\", x:25, y:85, fontSize:20, fontStyle:\"bold italic\", color:\"#08F\", textAlign:\"left\", textBaseline:\"top\"});\n\n    let yMenu = 350;\n    let yMenuStep = 40;\n    let selectedOption = -1;\n    for (let i = 0; i < menuOptions.length; i++)\n    {\n        let isHighlighted = aw.mousePos.y >= yMenu + yMenuStep*i && aw.mousePos.y < yMenu + yMenuStep*(i + 1) && aw.mousePos.x >= 0 && aw.mousePos.x < menuOptions[i].width;\n        let optionColor = isHighlighted ? \"#FF0\" : \"#FFF\";\n        \n        aw.ctx.shadowColor = optionColor;\n        aw.drawText({text:menuOptions[i].text, x:15, y:yMenu + yMenuStep*i, fontSize:35, fontStyle:\"bold italic\", color:optionColor, textAlign:\"left\", textBaseline:\"top\"}); \n\n        if (isHighlighted)\n        {\n            selectedOption = i;\n            aw.ctx.shadowColor = \"#888\";\n            aw.drawText({text:menuOptions[i].helpText, x:-15 + menuOptions[i].width, y:yMenu + yMenuStep*i + 12, fontSize:12, fontStyle:\"bold italic\", color:\"#888\", textAlign:\"left\", textBaseline:\"top\"}); \n        }\n    }\n\n    aw.ctx.restore();\n\n    if (selectedOption !== prevOption)\n    {\n        if (selectedOption !== -1)\n        {\n            aw.playNote(\"a\", 5, 0.025);\n        }\n        prevOption = selectedOption;\n    }\n    \n    if (selectedOption !== -1 && aw.mouseLeftButtonJustPressed)\n    {\n        difficultyMode = selectedOption;\n        lives = difficultyMode === 0 ? 10 : 5;\n        levelIdx = 0;\n        initLevel(levelIdx);\n        aw.mouseLeftButtonJustPressed = false;\n        aw.ctx.shadowBlur = 0;\n        aw.state = playing;\n        aw.statePost = drawUI;\n    }\n}\nfunction playing(deltaTime)\n{\n    aw.ctx.shadowBlur = 10;\n    renderBackgroundSpeedLines(deltaTime);\n\n    if (aw.keysJustPressed[\"escape\"] && difficultyMode === 2)\n    {\n        aw.clearAllEntities();\n        aw.mouseLeftButtonJustPressed = false;\n        aw.ctx.shadowBlur = 20;\n        aw.state = mainMenu;\n        aw.statePost = undefined;\n\n        aw.playNote(\"a\", 4, 0.05, 0.0);\n        aw.playNote(\"b\", 4, 0.05, 0.05);\n    }\n\n    if (player.isDead || level.isComplete())\n    {\n        endLevelTime -= deltaTime;\n        if (endLevelTime <= 0.0)\n        {\n            if (level.isComplete() && levelIdx === 19)\n            {\n                aw.state = gameOver;\n\n                for (let i = 0; i < 3; i++)\n                {\n                    aw.playNote(\"d\", 5, 0.05, i*0.3 + 0.0);\n                    aw.playNote(\"e\", 5, 0.05, i*0.3 + 0.05);\n                    aw.playNote(\"g\", 5, 0.05, i*0.3 + 0.1);\n                    aw.playNote(\"a\", 5, 0.05, i*0.3 + 0.15);\n                    aw.playNote(\"b\", 5, 0.05, i*0.3 + 0.2);\n                    aw.playNote(\"d\", 5, 0.05, i*0.3 + 0.25);\n                }\n                aw.playNote(\"c\", 6, 0.5, 0.9);\n            }\n            else if (lives === 0 && difficultyMode !== 2)\n            {\n                aw.state = gameOver;\n\n                aw.playNote(\"a#\", 4, 0.05, 0.0);\n                aw.playNote(\"g\", 4, 0.05, 0.05);\n                aw.playNote(\"e\", 4, 0.05, 0.10);\n                aw.playNote(\"d\", 4, 0.15, 0.15);\n            }\n            else if (player.isDead)\n            {\n                initLevel(levelIdx);\n            }\n            else\n            {\n                levelIdx = (levelIdx + 1) % 20;\n                initLevel(levelIdx);\n            }\n        }\n    }\n\n    updateCameraShake(deltaTime);\n    updateLevelScalePop(deltaTime);\n    setLevelCamera();\n}\n\nfunction initLevel(idx)\n{\n    aw.clearAllEntities();\n\n    startLevelScalePop();\n\n    updateCameraShake(0);\n    updateLevelScalePop(0);\n    setLevelCamera();\n\n    // TEMP TO WORK AROUND CLOSURE COMPILER ISSUES\n    if (idx == 0) { level = new L01() }\n    else if (idx == 1) { level = new L02() }\n    else if (idx == 2) { level = new L03() }\n    else if (idx == 3) { level = new L04() }\n    else if (idx == 4) { level = new L05() }\n    else if (idx == 5) { level = new L06() }\n    else if (idx == 6) { level = new L07() }\n    else if (idx == 7) { level = new L08() }\n    else if (idx == 8) { level = new L09() }\n    else if (idx == 9) { level = new L10() }\n    else if (idx == 10) { level = new L15() }\n    else if (idx == 11) { level = new L13() }\n    else if (idx == 12) { level = new L17() }\n    else if (idx == 13) { level = new L20() }\n    else if (idx == 14) { level = new L12() }\n    else if (idx == 15) { level = new L16() }\n    else if (idx == 16) { level = new L18() }\n    else if (idx == 17) { level = new L11() }\n    else if (idx == 18) { level = new L19() }\n    else if (idx == 19) { level = new L14() }\n    aw.addEntity(level);\n\n    player = new Player();\n    aw.addEntity(player);\n\n    endLevelTime = 1.0;\n    setBest();\n\n    aw.playNote(\"d\", 4, 0.05, 0.0);\n    aw.playNote(\"e\", 4, 0.05, 0.05);\n    aw.playNote(\"g\", 4, 0.05, 0.10);\n    aw.playNote(\"a#\", 4, 0.15, 0.15);\n}\nfunction gameOver(deltaTime)\n{\n    renderBackgroundSpeedLines(deltaTime);\n\n    if (aw.mouseLeftButtonJustPressed)\n    {\n        aw.clearAllEntities();\n        aw.mouseLeftButtonJustPressed = false;\n        aw.ctx.shadowBlur = 20;\n        aw.state = mainMenu;\n        aw.statePost = undefined;\n\n        aw.playNote(\"a\", 4, 0.05, 0.0);\n        aw.playNote(\"b\", 4, 0.05, 0.05);\n    }\n\n    updateCameraShake(deltaTime);\n    updateLevelScalePop(deltaTime);\n    setLevelCamera();\n}\nlet backgroundSpeedLines = [];\nvar speedLineSize = 400;\nvar speedLineSpeed = 4000;\nvar numSpeedLinesPerFrame = 2;\nfunction renderBackgroundSpeedLines(deltaTime)\n{\n    // This shouldn't be here\n    if (aw.keysJustPressed[\"s\"])\n    {\n        aw.soundOn = !aw.soundOn;\n    }\n\n    aw.ctx.save();\n    resetCamera();\n\n    for (let i = 0; i < numSpeedLinesPerFrame; i++)\n    {\n        backgroundSpeedLines.push({x:screenWidth, y:Math.random()*screenHeight, _remove:false});\n    }\n\n    aw.ctx.lineWidth = 2;\n    aw.ctx.strokeStyle = aw.state === mainMenu || aw.state === init ? \"#111\" : \"#090909\";\n    let shadowBlurSave = aw.ctx.shadowBlur;\n    aw.ctx.shadowBlur = 0;\n    \n    backgroundSpeedLines.forEach(speedLine =>\n    {\n        speedLine.x -= speedLineSpeed*deltaTime;\n        if (speedLine.x < -speedLineSize)\n        {\n            speedLine._remove = true;\n        }\n\n        aw.ctx.beginPath();\n        aw.ctx.moveTo(speedLine.x, speedLine.y);\n        aw.ctx.lineTo(speedLine.x + speedLineSize, speedLine.y);\n        aw.ctx.stroke();\n    });\n\n    backgroundSpeedLines = backgroundSpeedLines.filter(speedLine => speedLine._remove !== true);\n\n    aw.ctx.restore();\n    aw.ctx.shadowBlur = shadowBlurSave;\n}\nclass Level\n{\n    constructor()\n    {\n        this.linePoints = [];\n        this.segLengths = [];\n        this.totalDistance = [];\n        this.normals = [];\n        this.levelTime = 7.0;\n        this.timer = this.levelTime;\n\n        this.addPoints();\n        this.createSegments();\n        this.addItems();\n    }\n\n    addPoints()\n    {\n    }\n\n    createSegments()\n    {\n        for (let group = 0; group < this.linePoints.length; group++)\n        {\n            this.totalDistance.push(0);\n            this.segLengths.push([]);\n            for (let i = 0; i < this.linePoints[group].length - 1; i++)\n            {\n                let xDist = this.linePoints[group][i + 1].x - this.linePoints[group][i].x;\n                let yDist = this.linePoints[group][i + 1].y - this.linePoints[group][i].y;\n                let segDist = Math.sqrt((xDist*xDist) + (yDist*yDist));\n\n                this.totalDistance[group] += segDist;\n                this.segLengths[group].push(segDist);\n            }\n\n            let xDist = this.linePoints[group][0].x - this.linePoints[group][this.linePoints[group].length - 1].x;\n            let yDist = this.linePoints[group][0].y - this.linePoints[group][this.linePoints[group].length - 1].y;\n            let segDist = Math.sqrt((xDist*xDist) + (yDist*yDist));\n\n            this.totalDistance[group] += segDist;\n            this.segLengths[group].push(segDist);\n        }\n    }\n\n    addItems()\n    {\n    }\n\n    update(deltaTime)\n    {\n        if (difficultyMode == 2 && !this.isComplete() && !player.isDead)\n        {\n            this.timer = Math.max(this.timer - deltaTime, 0.0);\n            if (this.timer <= 0.0)\n            {\n                addDeathParticle(player.x, player.y);\n                player.hit();\n            }\n        }\n    }\n\n    render()\n    {\n        aw.ctx.lineWidth = 2;\n        aw.ctx.strokeStyle = \"#FFF\";\n        aw.ctx.shadowColor = \"#FFF\";\n        for (let group = 0; group < this.linePoints.length; group++)\n        {\n            aw.ctx.beginPath();\n            aw.ctx.moveTo(this.linePoints[group][0].x, this.linePoints[group][0].y);\n            for (let i = 1; i < this.linePoints[group].length; i++)\n            {\n                aw.ctx.lineTo(this.linePoints[group][i].x, this.linePoints[group][i].y);\n            }\n            aw.ctx.lineTo(this.linePoints[group][0].x, this.linePoints[group][0].y);\n            aw.ctx.stroke();\n        }\n    }\n\n    getStartPos()\n    {\n        return this.linePoints[0][0];\n    }\n\n    getPosInfo(group, distance)\n    {\n        distance = distance % this.totalDistance[group];\n\n        let curTotalDistance = 0;\n        for (let i = 0; i < this.segLengths[group].length; i++)\n        {\n            let nextTotalDistance = curTotalDistance + this.segLengths[group][i];\n            if (distance >= curTotalDistance && distance < nextTotalDistance)\n            {\n                let ratio = (distance - curTotalDistance) / this.segLengths[group][i];\n                let p1 = i;\n                let p2 = (i + 1) % this.linePoints[group].length;\n                let xDir = this.linePoints[group][p2].x - this.linePoints[group][p1].x;\n                let yDir = this.linePoints[group][p2].y - this.linePoints[group][p1].y;\n                let xInterp = this.linePoints[group][p1].x + xDir*ratio;\n                let yInterp = this.linePoints[group][p1].y + yDir*ratio;\n\n                if (this.normals[group] !== undefined && this.normals[group][i] !== undefined)\n                {\n                    return {x:xInterp, y:yInterp, nx:this.normals[group][i].x, ny:this.normals[group][i].y, xDir:xDir, yDir:yDir};\n                }\n                else\n                {\n                    let xDir = (this.linePoints[group][p2].x - this.linePoints[group][p1].x) / this.segLengths[group][i];\n                    let yDir = (this.linePoints[group][p2].y - this.linePoints[group][p1].y) / this.segLengths[group][i];\n                    return {x:xInterp, y:yInterp, nx:yDir, ny:-xDir, xDir:xDir, yDir:yDir};\n                }\n            }\n\n            curTotalDistance = nextTotalDistance;\n        }\n\n        return {x:this.linePoints[0][0].x, y:this.linePoints[0][0].y};\n    }\n\n    getIntersectionInfo(x1, y1, x2, y2)\n    {\n        for (let group = 0; group < this.segLengths.length; group++)\n        {\n            let curTotalDistance = 0;\n            for (let i = 0; i < this.segLengths[group].length; i++)\n            {\n                let p1 = i;\n                let p2 = (i + 1) % this.linePoints[group].length;\n\n                let lineIntersectInfo = getLineIntersectionInfo(this.linePoints[group][p1].x, this.linePoints[group][p1].y, this.linePoints[group][p2].x, this.linePoints[group][p2].y, x1, y1, x2, y2);\n                if (lineIntersectInfo.intersect)\n                {\n                    lineIntersectInfo.distance = curTotalDistance + this.segLengths[group][i]*lineIntersectInfo.time;\n                    lineIntersectInfo.group = group;\n                    return lineIntersectInfo;\n                }\n\n                curTotalDistance += this.segLengths[group][i];\n            }\n        }\n\n        return {intersect:false};\n    }\n\n    isComplete()\n    {\n        let isComplete = true;\n        aw.entities.forEach(entity =>\n        {\n            if (entity instanceof Coin)\n            {\n                if (entity.active)\n                {\n                    isComplete = false;\n                }\n            }\n        });\n\n        return isComplete;\n    }\n}\nclass L01 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-100, y:100});\n        this.linePoints[0].push({x:100, y: 100});\n        this.linePoints[0].push({x:100, y: -100});\n        this.linePoints[0].push({x:-100, y: -100});\n\n        this.name = \"THE BOX\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(-50, 0));\n        aw.addEntity(new Coin(50, 0));\n        aw.addEntity(new Coin(-25, 0));\n        aw.addEntity(new Coin(25, 0));\n\n        aw.addEntity(new Coin(0, 50));\n        aw.addEntity(new Coin(-50, 50));\n        aw.addEntity(new Coin(50, 50));\n        aw.addEntity(new Coin(-25, 50));\n        aw.addEntity(new Coin(25, 50));\n\n        aw.addEntity(new Coin(0, -50));\n        aw.addEntity(new Coin(-50, -50));\n        aw.addEntity(new Coin(50, -50));\n        aw.addEntity(new Coin(-25, -50));\n        aw.addEntity(new Coin(25, -50));\n    }\n}\nclass L02 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-200, y:100});\n        this.linePoints[0].push({x:200, y: 100});\n        this.linePoints[0].push({x:200, y: -100});\n        this.linePoints[0].push({x:-200, y: -100});\n\n        this.name = \"PEGBOARD\";\n    }\n\n    addItems()\n    {\n        let xCols = [-150, -75, 0, 75, 150];\n        let yCols = [-60, -20, 20, 60];\n        for (let y = 0; y < yCols.length; y++)\n        {\n            for (let x = 0; x < xCols.length; x++)\n            {\n                aw.addEntity(new Coin(xCols[x], yCols[y]));\n            }\n        }\n    }\n}\nclass L03 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        let radius = 150;\n        let numPoints = 90;\n        let angleStep = (360 / numPoints) * Math.PI/180;\n        for (let i = 0; i < numPoints; i++)\n        {\n            let angle = Math.PI*2 - (i * angleStep);\n            let x = Math.cos(angle) * radius;\n            let y = Math.sin(angle) * radius;\n            this.linePoints[0].push({x:x, y:y});\n        }\n\n        this.name = \"ORBIT\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(0, 0, 50, 90, 70));\n        aw.addEntity(new Coin(0, 0, 100, 90, 70));\n        aw.addEntity(new Coin(0, 0, 50, 270, 70));\n        aw.addEntity(new Coin(0, 0, 100, 270, 70));\n    }\n}\nclass L04 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-60, y:150});\n        this.linePoints[0].push({x:60, y: 150});\n        this.linePoints[0].push({x:60, y: -150});\n        this.linePoints[0].push({x:-60, y: -150});\n\n        this.name = \"NEEDLE\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(0, 50));\n        aw.addEntity(new Coin(0, -50));\n\n        aw.addEntity(new Wall(-40, 25, 40, 0));\n        aw.addEntity(new Wall(40, -25, 40, 0));\n        aw.addEntity(new Wall(40, 75, 40, 0));\n        aw.addEntity(new Wall(-40, -75, 40, 0));\n    }\n}\nclass L05 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-200, y:0});\n        this.linePoints[0].push({x:0, y:200});\n        this.linePoints[0].push({x:200, y:0});\n        this.linePoints[0].push({x:0, y:-200});\n\n        this.levelTime = 12.0;\n        this.timer = this.levelTime;\n        this.name = \"PATIENCE\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Wall(0, 0, 250, 0, 40));\n\n        aw.addEntity(new Coin(0, 120));\n        aw.addEntity(new Coin(30, 90));\n        aw.addEntity(new Coin(60, 60));\n        aw.addEntity(new Coin(90, 30));\n\n        aw.addEntity(new Coin(-30, 90));\n        aw.addEntity(new Coin(-60, 60));\n        aw.addEntity(new Coin(-90, 30));\n        aw.addEntity(new Coin(-120, 0));\n\n        aw.addEntity(new Coin(-90, -30));\n        aw.addEntity(new Coin(-60, -60));\n        aw.addEntity(new Coin(-30, -90));\n        aw.addEntity(new Coin(0, -120));\n\n        aw.addEntity(new Coin(30, -90));\n        aw.addEntity(new Coin(60, -60));\n        aw.addEntity(new Coin(90, -30));\n        aw.addEntity(new Coin(120,  0));\n    }\n}\nclass L06 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-200, y:200});\n        this.linePoints[0].push({x:-50, y: 200});\n        this.linePoints[0].push({x:-50, y: 20});\n        this.linePoints[0].push({x:200, y: 20});\n\n        this.linePoints[0].push({x:200, y:-200});\n        this.linePoints[0].push({x:50, y: -200});\n        this.linePoints[0].push({x:50, y: -20});\n        this.linePoints[0].push({x:-200, y: -20});\n\n        this.name = \"BOOMERANG\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(-30, 0));\n        aw.addEntity(new Coin(-60, 0));\n        aw.addEntity(new Coin(30, 0));\n        aw.addEntity(new Coin(60, 0));\n        aw.addEntity(new Coin(90, 0));\n        aw.addEntity(new Coin(-90, 0));\n        aw.addEntity(new Coin(120, 0));\n        aw.addEntity(new Coin(-120, 0));\n\n        aw.addEntity(new Wall(-125, 160, 150));\n        aw.addEntity(new Wall(125, -160, 150));\n        aw.addEntity(new Coin(-125, 180));\n        aw.addEntity(new Coin(125, -180));\n\n        aw.addEntity(new Wall(-60, 40, 40, 90));\n        aw.addEntity(new Wall(60, -40, 40, 90));\n    }\n}\nclass L07 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:50, y:-100});\n        this.linePoints[0].push({x:-50, y:-100});\n        this.normals.push([]);\n        this.normals[0].push({x:0, y:1});\n        this.normals[0].push({x:0, y:1});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-125, y:100});\n        this.linePoints[1].push({x:-25, y:100});\n        this.normals.push([]);\n        this.normals[1].push({x:0, y:-1});\n        this.normals[1].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:125, y:100});\n        this.linePoints[2].push({x:25, y:100});\n        this.normals.push([]);\n        this.normals[2].push({x:0, y:-1});\n        this.normals[2].push({x:0, y:-1});\n\n        this.name = \"SPLITTER\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-35, -50));\n        aw.addEntity(new Coin(-35, -25));\n        aw.addEntity(new Coin(-35, 0));\n        aw.addEntity(new Coin(-35, 25));\n        aw.addEntity(new Coin(-35, 50));\n\n        aw.addEntity(new Coin(35, -50));\n        aw.addEntity(new Coin(35, -25));\n        aw.addEntity(new Coin(35, 0));\n        aw.addEntity(new Coin(35, 25));\n        aw.addEntity(new Coin(35, 50));\n    }\n}\nclass L08 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-250, y:-100});\n        this.linePoints[0].push({x:250, y: -100});\n        this.normals.push([]);\n        this.normals[0].push({x:0, y:1});\n        this.normals[0].push({x:0, y:1});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-140, y:100});\n        this.linePoints[1].push({x:-110, y:100});\n        this.normals.push([]);\n        this.normals[1].push({x:0, y:-1});\n        this.normals[1].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:140, y:100});\n        this.linePoints[2].push({x:110, y:100});\n        this.normals.push([]);\n        this.normals[2].push({x:0, y:-1});\n        this.normals[2].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:-15, y:100});\n        this.linePoints[3].push({x:15, y:100});\n        this.normals.push([]);\n        this.normals[3].push({x:0, y:-1});\n        this.normals[3].push({x:0, y:-1});\n\n        this.levelTime = 12.0;\n        this.timer = this.levelTime;\n\n        this.name = \"TRIPLE SHOT\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-125, -50));\n        aw.addEntity(new Coin(-125, 0));\n        aw.addEntity(new Coin(-125, 50));\n\n        aw.addEntity(new Coin(0, -50));\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(0, 50));\n\n        aw.addEntity(new Coin(125, -50));\n        aw.addEntity(new Coin(125, 0));\n        aw.addEntity(new Coin(125, 50));\n    }\n}\nclass L09 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        let radius = 150;\n        let numPoints = 90;\n        let angleStep = (360 / numPoints) * Math.PI/180;\n        for (let i = 0; i < numPoints; i++)\n        {\n            let angle = Math.PI*2 - (i * angleStep);\n            let x = Math.cos(angle) * radius;\n            let y = Math.sin(angle) * radius;\n            this.linePoints[0].push({x:x, y:y});\n        }\n\n        this.linePoints.push([]);\n        radius = 100;\n        numPoints = 45;\n        angleStep = (360 / numPoints) * Math.PI/180;\n        for (let i = 0; i < numPoints; i++)\n        {\n            let angle = i * angleStep;\n            let x = Math.cos(angle) * radius;\n            let y = Math.sin(angle) * radius;\n            this.linePoints[1].push({x:x, y:y});\n        }\n\n        this.name = \"DONUT\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 115));\n        aw.addEntity(new Coin(0, 135));\n\n        aw.addEntity(new Coin(0, -115));\n        aw.addEntity(new Coin(0, -135));\n\n        aw.addEntity(new Coin(115, 0));\n        aw.addEntity(new Coin(135, 0));\n\n        aw.addEntity(new Coin(-115, 0));\n        aw.addEntity(new Coin(-135, 0));\n\n        aw.addEntity(new Wall(81, 81, 140, -45));\n        aw.addEntity(new Wall(-81, 81, 140, 45));\n        aw.addEntity(new Wall(81, -81, 140, 45));\n        aw.addEntity(new Wall(-81, -81, 140, -45));\n    }\n}\nclass L10 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-300, y:100});\n        this.linePoints[0].push({x:-300, y:-100});\n        this.normals.push([]);\n        this.normals[0].push({x:1, y:0});\n        this.normals[0].push({x:1, y:0});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:300, y:100});\n        this.linePoints[1].push({x:300, y:-100});\n        this.normals.push([]);\n        this.normals[1].push({x:-1, y:0});\n        this.normals[1].push({x:-1, y:0});\n\n        this.name = \"LONG DISTANCE\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-50, 0));\n        aw.addEntity(new Coin(50, 0));\n        aw.addEntity(new Coin(100, 0));\n        aw.addEntity(new Coin(-100, 0));\n        aw.addEntity(new Coin(200, 0));\n        aw.addEntity(new Coin(-200, 0));\n        aw.addEntity(new Coin(250, 0));\n        aw.addEntity(new Coin(-250, 0));\n\n        aw.addEntity(new Wall(0, -100, 75, 90, 0, 0, 200, 1.0, 0.5));\n        aw.addEntity(new Wall(-150, -100, 75, 90, 0, 0, 200, 1.5, 0.5));\n        aw.addEntity(new Wall(150, -100, 75, 90, 0, 0, 200, 0.5, 0.5));\n    }\n}\nclass L11 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-300, y:0});\n        this.linePoints[0].push({x:-225, y: 0});\n        this.linePoints[0].push({x:-225, y: 50});\n        this.linePoints[0].push({x:225, y: 50});\n        this.linePoints[0].push({x:225, y: 0});\n        this.linePoints[0].push({x:300, y: 0});\n        this.linePoints[0].push({x:225, y: 0});\n        this.linePoints[0].push({x:225, y: -50});\n        this.linePoints[0].push({x:-225, y: -50});\n        this.linePoints[0].push({x:-225, y: 0});\n\n        this.name = \"CIRCUIT\";\n    }\n\n    addItems()\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            aw.addEntity(new Coin(-125 + 50*i, 30));\n            aw.addEntity(new Coin(-125 + 50*i, 0));\n            aw.addEntity(new Coin(-125 + 50*i, -30));\n        }\n\n        aw.addEntity(new Wall(0, -50, 50, 90));\n        aw.addEntity(new Wall(-50, 50, 50, 90));\n        aw.addEntity(new Wall(50, 50, 50, 90));\n        aw.addEntity(new Wall(-100, -50, 50, 90));\n        aw.addEntity(new Wall(100, -50, 50, 90));\n        aw.addEntity(new Wall(-150, 50, 50, 90));\n        aw.addEntity(new Wall(150, 50, 50, 90));\n    }\n}\nclass L12 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-225, y:150});\n        this.linePoints[0].push({x:-225, y:50});\n        this.linePoints[0].push({x:-125, y:50});\n        this.linePoints[0].push({x:-125, y:150});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:175, y:125});\n        this.linePoints[1].push({x:175, y:75});\n        this.linePoints[1].push({x:225, y:75});\n        this.linePoints[1].push({x:225, y:125});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:150, y:-75});\n        this.linePoints[2].push({x:150, y:-125});\n        this.linePoints[2].push({x:200, y:-125});\n        this.linePoints[2].push({x:200, y:-75});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:-200, y:-85});\n        this.linePoints[3].push({x:-200, y:-110});\n        this.linePoints[3].push({x:-175, y:-110});\n        this.linePoints[3].push({x:-175, y:-85});\n\n        this.name = \"QUADS\";\n    }\n\n    addItems()\n    {\n        for (let i = 0; i < 5; i++)\n        {\n            aw.addEntity(new Coin(-75 + i*50, 100));\n        }\n\n        for (let i = 0; i < 6; i++)\n        {\n            aw.addEntity(new Coin(-135 + i*50, -97.5));\n        }\n\n        for (let i = 0; i < 2; i++)\n        {\n            aw.addEntity(new Coin(-187.5, 10 - i*50));\n        }\n\n        for (let i = 0; i < 3; i++)\n        {\n            aw.addEntity(new Coin(187.5, 50 - i*50));\n        }\n    }\n}\nclass L13 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-300, y:100});\n\n        this.linePoints[0].push({x:-145, y:100});\n        this.linePoints[0].push({x:-135, y:80});\n        this.linePoints[0].push({x:-115, y:80});\n        this.linePoints[0].push({x:-105, y:100});\n\n        this.linePoints[0].push({x:105, y:100});\n        this.linePoints[0].push({x:115, y:80});\n        this.linePoints[0].push({x:135, y:80});\n        this.linePoints[0].push({x:145, y:100});\n\n        this.linePoints[0].push({x:300, y: 100});\n\n        this.linePoints[0].push({x:300, y:20});\n        this.linePoints[0].push({x:280, y:10});\n        this.linePoints[0].push({x:280, y:-10});\n        this.linePoints[0].push({x:300, y:-20});\n\n        this.linePoints[0].push({x:300, y: -100});\n\n        this.linePoints[0].push({x:145, y:-100});\n        this.linePoints[0].push({x:135, y:-80});\n        this.linePoints[0].push({x:115, y:-80});\n        this.linePoints[0].push({x:105, y:-100});\n\n        this.linePoints[0].push({x:-105, y:-100});\n        this.linePoints[0].push({x:-115, y:-80});\n        this.linePoints[0].push({x:-135, y:-80});\n        this.linePoints[0].push({x:-145, y:-100});\n\n        this.linePoints[0].push({x:-300, y: -100});\n\n        this.linePoints[0].push({x:-300, y:-20});\n        this.linePoints[0].push({x:-280, y:-10});\n        this.linePoints[0].push({x:-280, y:10});\n        this.linePoints[0].push({x:-300, y:20});\n\n        this.name = \"RAZOR\";\n    }\n\n    addItems()\n    {\n        for (let i = 0; i < 10; i++)\n        {\n            aw.addEntity(new Coin(-225 + i*50, 0));\n        }\n        \n        aw.addEntity(new Coin(-125, 40));\n        aw.addEntity(new Coin(-125, -40));\n        aw.addEntity(new Coin(125, 40));\n        aw.addEntity(new Coin(125, -40));\n    }\n}\nclass L14 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.normals.push([]);\n        let radius = 70;\n        let numPoints = 45;\n        let angleStep = (360 / numPoints) * Math.PI/180;\n        for (let i = 0; i < numPoints; i++)\n        {\n            let angle = i * angleStep;\n            let x = Math.cos(angle) * radius;\n            let y = Math.sin(angle) * radius;\n            this.linePoints[0].push({x:x, y:y});\n        }\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-300, y:50});\n        this.linePoints[1].push({x:-300, y:-50});\n        this.normals.push([]);\n        this.normals[1].push({x:1, y:0});\n        this.normals[1].push({x:1, y:0});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:215, y:-135});\n        this.linePoints[2].push({x:135, y:-215});\n        this.normals.push([]);\n        this.normals[2].push({x:-0.707, y:0.707});\n        this.normals[2].push({x:-0.707, y:0.707});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:175, y:125});\n        this.linePoints[3].push({x:125, y:175});\n        this.normals.push([]);\n        this.normals[3].push({x:-0.707, y:-0.707});\n        this.normals[3].push({x:-0.707, y:-0.707});\n\n        this.name = \"ALIENS\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-112, 0));\n        aw.addEntity(new Coin(-162, 0));\n        aw.addEntity(new Coin(-212, 0));\n        aw.addEntity(new Coin(-262, 0));\n\n        aw.addEntity(new Coin(80, -80));\n        aw.addEntity(new Coin(110, -110));\n        aw.addEntity(new Coin(140, -140));\n\n        aw.addEntity(new Coin(85, 85));\n        aw.addEntity(new Coin(120, 120));\n\n        aw.addEntity(new Wall(-188, 150, 75, 90, 0, 0, -300, 0.5, 0.5));\n        aw.addEntity(new Wall(0, 205, 75, -45, 0, 215, -215, 0.5, 0.5));\n    }\n}\nclass L15 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-280, y:150});\n        this.linePoints[0].push({x:-280, y: -150});\n        this.linePoints[0].push({x:-260, y: -150});\n        this.linePoints[0].push({x:-260, y: 150});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-100, y:100});\n        this.linePoints[1].push({x:-100, y: -100});\n        this.linePoints[1].push({x:-80, y: -100});\n        this.linePoints[1].push({x:-80, y: 100});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:80, y:50});\n        this.linePoints[2].push({x:80, y: -50});\n        this.linePoints[2].push({x:100, y: -50});\n        this.linePoints[2].push({x:100, y: 50});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:260, y:25});\n        this.linePoints[3].push({x:260, y: -25});\n        this.linePoints[3].push({x:280, y: -25});\n        this.linePoints[3].push({x:280, y: 25});\n\n        this.name = \"BAR GAPS\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-130, 0));\n        aw.addEntity(new Coin(-180, 0));\n        aw.addEntity(new Coin(-230, 0));\n\n        aw.addEntity(new Coin(-130, 80));\n        aw.addEntity(new Coin(-180, 80));\n        aw.addEntity(new Coin(-230, 80));\n\n        aw.addEntity(new Coin(-130, -80));\n        aw.addEntity(new Coin(-180, -80));\n        aw.addEntity(new Coin(-230, -80));\n\n        aw.addEntity(new Coin(-50, -30));\n        aw.addEntity(new Coin(0, -30));\n        aw.addEntity(new Coin(50, -30));\n\n        aw.addEntity(new Coin(-50, 30));\n        aw.addEntity(new Coin(0, 30));\n        aw.addEntity(new Coin(50, 30));\n\n        aw.addEntity(new Coin(130, 0));\n        aw.addEntity(new Coin(180, 0));\n        aw.addEntity(new Coin(230, 0));\n    }\n}\nclass L16 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-275, y:-200});\n        this.linePoints[0].push({x:-250, y:-200});\n        this.normals.push([]);\n        this.normals[0].push({x:0, y: 1});\n        this.normals[0].push({x:0, y: 1});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-275, y:0});\n        this.linePoints[1].push({x:-250, y:25});\n        this.normals.push([]);\n        this.normals[1].push({x:0.707, y: -0.707});\n        this.normals[1].push({x:0.707, y: -0.707});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:-150, y:-200});\n        this.linePoints[2].push({x:-25, y:-200});\n        this.normals.push([]);\n        this.normals[2].push({x:0, y: 1});\n        this.normals[2].push({x:0, y: 1});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:-75, y:100});\n        this.linePoints[3].push({x:-50, y:125});\n        this.normals.push([]);\n        this.normals[3].push({x:0.707, y: -0.707});\n        this.normals[3].push({x:0.707, y: -0.707});\n\n        this.linePoints.push([]);\n        this.linePoints[4].push({x:160, y:-200});\n        this.linePoints[4].push({x:285, y:-200});\n        this.normals.push([]);\n        this.normals[4].push({x:0, y: 1});\n        this.normals[4].push({x:0, y: 1});\n\n        this.linePoints.push([]);\n        this.linePoints[5].push({x:160, y:180});\n        this.linePoints[5].push({x:285, y:180});\n        this.normals.push([]);\n        this.normals[5].push({x:0, y: -1});\n        this.normals[5].push({x:0, y: -1});\n\n        this.levelTime = 12.0;\n        this.timer = this.levelTime;\n\n        this.name = \"ZIG ZAG\";\n    }\n\n    addItems()\n    {\n        for (let i = 0; i < 3; i++)\n        {\n            aw.addEntity(new Coin(-262, -150 + i*50));\n        }\n\n        for (let i = 1; i < 4; i++)\n        {\n            aw.addEntity(new Coin(-262 + i*50, 12 - i*50));\n        }\n\n        for (let i = 0; i < 5; i++)\n        {\n            aw.addEntity(new Coin(-62, -150 + i*50));\n        }\n\n        for (let i = 1; i < 6; i++)\n        {\n            aw.addEntity(new Coin(-62 + i*50, 112 - i*50));\n        }\n\n        for (let i = 0; i < 7; i++)\n        {\n            aw.addEntity(new Coin(222, -150 + i*50));\n        }\n\n        aw.addEntity(new Wall(-225, -75, 100, 0, -180));\n        aw.addEntity(new Wall(-12, 0, 125, 0, 180));\n\n        aw.addEntity(new Wall(222, 50, 100, 0, 0, -100, 0, 1.0, 0.5));\n        aw.addEntity(new Wall(222, -50, 100, 0, 0, 100, 0, 1.0, 0.5));\n    }\n}\nclass L17 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        let radius = 300;\n        let numPoints = 90;\n        let angleStep = (360 / numPoints) * Math.PI/180;\n        for (let i = 0; i < numPoints / 4; i++)\n        {\n            let angle = Math.PI*1.745 - (i * angleStep);\n            let x = Math.cos(angle) * radius;\n            let y = Math.sin(angle) * radius;\n            this.linePoints[0].push({x:x, y:y + 150});\n        }\n\n        this.linePoints[0].push({x:-50, y:150});\n        this.linePoints[0].push({x:50, y:150});\n\n        this.name = \"SHELL\";\n    }\n\n    addItems()\n    {\n        let xStart = -60;\n        let yStart = 95;\n        let stepSize = 50;\n        let xStep = Math.cos(235 * Math.PI/180) * stepSize;\n        let yStep = Math.sin(235 * Math.PI/180) * stepSize;\n        for (let i = 0; i < 4; i++)\n        {\n            aw.addEntity(new Coin(-xStart - xStep*i, yStart + yStep*i));\n            aw.addEntity(new Coin(xStart + xStep*i, yStart + yStep*i));\n        }\n\n        xStart = -17;\n        yStart = 85;\n        stepSize = 50;\n        xStep = Math.cos(255 * Math.PI/180) * stepSize;\n        yStep = Math.sin(255 * Math.PI/180) * stepSize;\n        for (let i = 0; i < 4; i++)\n        {\n            aw.addEntity(new Coin(-xStart - xStep*i, yStart + yStep*i));\n            aw.addEntity(new Coin(xStart + xStep*i, yStart + yStep*i));\n        }\n\n        aw.addEntity(new Wall(0, 0, 150, 90));\n        aw.addEntity(new Wall(75, 20, 150, -60));\n        aw.addEntity(new Wall(-75, 20, 150, 60));\n    }\n}\nclass L18 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-250, y:0});\n        this.linePoints[0].push({x:-250, y:50});\n        this.linePoints[0].push({x:250, y:50});\n        this.linePoints[0].push({x:-250, y:50});\n        this.normals.push([]);\n        this.normals[0].push({x:1, y:0});\n        this.normals[0].push({x:0, y:-1});\n        this.normals[0].push({x:0, y:-1});\n        this.normals[0].push({x:1, y:0});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:250, y:0});\n        this.linePoints[1].push({x:250, y:-50});\n        this.linePoints[1].push({x:-250, y:-50});\n        this.linePoints[1].push({x:250, y:-50});\n        this.normals.push([]);\n        this.normals[1].push({x:-1, y:0});\n        this.normals[1].push({x:0, y:1});\n        this.normals[1].push({x:0, y:1});\n        this.normals[1].push({x:-1, y:0});\n\n        this.name = \"X FACTOR\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, -25));\n        aw.addEntity(new Coin(0, 25));\n\n        aw.addEntity(new Coin(100, -25));\n        aw.addEntity(new Coin(100, 25));\n\n        aw.addEntity(new Coin(-100, -25));\n        aw.addEntity(new Coin(-100, 25));\n\n        aw.addEntity(new Coin(200, -25));\n        aw.addEntity(new Coin(200, 25));\n\n        aw.addEntity(new Coin(-200, -25));\n        aw.addEntity(new Coin(-200, 25));\n\n        aw.addEntity(new Wall(200, 0, 80, 0, 270, -400, 0, 0.75, 0));\n        aw.addEntity(new Wall(200, 0, 80, 90, 270, -400, 0, 0.75, 0));\n    }\n}\nclass L19 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-150, y:150});\n        this.linePoints[0].push({x:-200, y:150});\n        this.linePoints[0].push({x:-200, y:100});\n        this.linePoints[0].push({x:-200, y:150});\n        this.normals.push([]);\n        this.normals[0].push({x:0, y:-1});\n        this.normals[0].push({x:1, y:0});\n        this.normals[0].push({x:1, y:0});\n        this.normals[0].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[1].push({x:-150, y:0});\n        this.linePoints[1].push({x:-200, y:0});\n        this.linePoints[1].push({x:-200, y:50});\n        this.linePoints[1].push({x:-200, y:0});\n        this.normals.push([]);\n        this.normals[1].push({x:0, y:1});\n        this.normals[1].push({x:1, y:0});\n        this.normals[1].push({x:1, y:0});\n        this.normals[1].push({x:0, y:1});\n\n        this.linePoints.push([]);\n        this.linePoints[2].push({x:150, y:50});\n        this.linePoints[2].push({x:200, y:50});\n        this.linePoints[2].push({x:200, y:0});\n        this.linePoints[2].push({x:200, y:50});\n        this.normals.push([]);\n        this.normals[2].push({x:0, y:-1});\n        this.normals[2].push({x:-1, y:0});\n        this.normals[2].push({x:-1, y:0});\n        this.normals[2].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[3].push({x:150, y:-100});\n        this.linePoints[3].push({x:200, y:-100});\n        this.linePoints[3].push({x:200, y:-50});\n        this.linePoints[3].push({x:200, y:-100});\n        this.normals.push([]);\n        this.normals[3].push({x:0, y:1});\n        this.normals[3].push({x:-1, y:0});\n        this.normals[3].push({x:-1, y:0});\n        this.normals[3].push({x:0, y:1});\n\n        this.linePoints.push([]);\n        this.linePoints[4].push({x:-150, y:-50});\n        this.linePoints[4].push({x:-200, y:-50});\n        this.linePoints[4].push({x:-200, y:-100});\n        this.linePoints[4].push({x:-200, y:-50});\n        this.normals.push([]);\n        this.normals[4].push({x:0, y:-1});\n        this.normals[4].push({x:1, y:0});\n        this.normals[4].push({x:1, y:0});\n        this.normals[4].push({x:0, y:-1});\n\n        this.linePoints.push([]);\n        this.linePoints[5].push({x:-150, y:-200});\n        this.linePoints[5].push({x:-200, y:-200});\n        this.linePoints[5].push({x:-200, y:-150});\n        this.linePoints[5].push({x:-200, y:-200});\n        this.normals.push([]);\n        this.normals[5].push({x:0, y:1});\n        this.normals[5].push({x:1, y:0});\n        this.normals[5].push({x:1, y:0});\n        this.normals[5].push({x:0, y:1});\n\n        this.linePoints.push([]);\n        this.linePoints[6].push({x:150, y:-200});\n        this.linePoints[6].push({x:200, y:-200});\n        this.linePoints[6].push({x:200, y:-150});\n        this.linePoints[6].push({x:200, y:-200});\n        this.normals.push([]);\n        this.normals[6].push({x:0, y:1});\n        this.normals[6].push({x:-1, y:0});\n        this.normals[6].push({x:-1, y:0});\n        this.normals[6].push({x:0, y:1});\n\n        this.levelTime = 12.0;\n        this.timer = this.levelTime;\n        this.name = \"SNAKE\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(-175, 125));\n        aw.addEntity(new Coin(-175, 75));\n        aw.addEntity(new Coin(-175, 25));\n\n        for (let i = 0; i < 7; i++)\n        {\n            aw.addEntity(new Coin(-125 + 50*i, 25));\n            aw.addEntity(new Coin(-125 + 50*i, -75));\n            aw.addEntity(new Coin(-125 + 50*i, -175));\n        }\n\n        aw.addEntity(new Coin(175, -25));\n        aw.addEntity(new Coin(-175, -75));\n        aw.addEntity(new Coin(-175, -125));\n        aw.addEntity(new Coin(-175, -175));\n\n        aw.addEntity(new Wall(0, -25, 150, 0, 180));\n    }\n}\nclass L20 extends Level\n{\n    addPoints()\n    {\n        this.linePoints.push([]);\n        this.linePoints[0].push({x:-100, y:100});\n        this.linePoints[0].push({x:100, y: 100});\n        this.linePoints[0].push({x:100, y: -100});\n        this.linePoints[0].push({x:-100, y: -100});\n\n        this.name = \"REVENGE OF THE BOX\";\n    }\n\n    addItems()\n    {\n        aw.addEntity(new Coin(0, 0));\n        aw.addEntity(new Coin(-50, 0));\n        aw.addEntity(new Coin(50, 0));\n        aw.addEntity(new Coin(-25, 0));\n        aw.addEntity(new Coin(25, 0));\n\n        aw.addEntity(new Coin(0, 50));\n        aw.addEntity(new Coin(-50, 50));\n        aw.addEntity(new Coin(50, 50));\n        aw.addEntity(new Coin(-25, 50));\n        aw.addEntity(new Coin(25, 50));\n\n        aw.addEntity(new Coin(0, -50));\n        aw.addEntity(new Coin(-50, -50));\n        aw.addEntity(new Coin(50, -50));\n        aw.addEntity(new Coin(-25, -50));\n        aw.addEntity(new Coin(25, -50));\n\n        aw.addEntity(new Wall(-32, 32, 50, 0, 180));\n        aw.addEntity(new Wall(38, -50, 50, 90, 0, 0, 50, 1.0, 0.5));\n    }\n}\nclass Aw\n{\n    //////////////////////////\n    //-------- CORE --------//\n    //////////////////////////\n\n    constructor(width, height, scale, assetList)\n    {\n        this.initDisplay(width, height, scale);\n        this.initEntities();\n        this.initInput();\n        this.initAudio();\n\n        this.loadAssets(assetList);\n\n        this.gameLoop(performance.now());\n    }\n\n    initDisplay(width, height, scale)\n    {\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.setAttribute(\"width\", width);\n        this.canvas.setAttribute(\"height\", height);\n        this.canvas.style.width = `${width * scale}px`;\n        this.canvas.style.height = `${height * scale}px`;\n        this.canvas.style.backgroundColor = \"black\";\n        //this.canvas.style[\"image-rendering\"] = \"pixelated\";\n        document.getElementById(\"game\").appendChild(this.canvas);\n\n        this.ctx = this.canvas.getContext('2d');\n        this.width = width;\n        this.height = height;\n        this.scale = scale;\n    }\n\n    loadAssets(assetList)\n    {\n        this.assets = {};\n\n        assetList.forEach(assetName =>\n        {\n            this.assets[assetName] = {};\n            this.assets[assetName].loaded = false;\n\n            if (assetName.endsWith(\".png\") || assetName.endsWith(\".jpg\"))\n            {\n                this.assets[assetName].data = new Image();\n                this.assets[assetName].data.onload = () => this.assets[assetName].loaded = true;\n                this.assets[assetName].data.src = assetName;\n            }\n            else if (assetName.endsWith(\".wav\") || assetName.endsWith(\".mp3\"))\n            {\n                this.assets[assetName].data = new Audio();\n                //this.assets[assetName].data.addEventListener(\"load\", () => this.assets[assetName].loaded = true, true);\n                this.assets[assetName].data.src = assetName;\n                this.assets[assetName].data.load();\n                this.assets[assetName].loaded = true;\n            }\n            else\n            {\n                console.assert(false, `Unable to load ${assetName} - unknown type`);\n            }\n        });\n    }\n\n    isLoading()\n    {\n        return Object.keys(this.assets).length > 0 && Object.values(this.assets).every(asset => asset.loaded) == false;\n    }\n\n    getAsset(assetName)\n    {\n        console.assert(this.assets[assetName] !== undefined, `No asset loaded named '${assetName}'`);\n        return this.assets[assetName].data;\n    }\n\n    gameLoop(curTime)\n    {\n        window.requestAnimationFrame(this.gameLoop.bind(this));\n        \n        if (this.isLoading()) { return; }\n\n        let deltaTime = Math.min((curTime - (this.lastTime || curTime)) / 1000.0, 0.2);  // Cap to 200ms (5fps)\n        this.lastTime = curTime;\n\n        this.ctx.clearRect(-this.width, -this.height, this.width*2.0, this.height*2.0);\n\n        if (this.state !== undefined)\n        {\n            this.state(deltaTime);\n        }\n\n        this.sortEntities();\n        this.updateEntities(deltaTime);\n        this.renderEntities();\n\n        if (this.statePost !== undefined)\n        {\n            this.statePost(deltaTime);\n        }\n\n        this.postUpdateInput();\n    }\n\n    //////////////////////////\n    //------ ENTITIES ------//\n    //////////////////////////\n\n    initEntities()\n    {\n        this.entities = [];\n        this.entitiesNeedSorting = false;\n        this.entitiesNeedRemoval = false;\n    }\n\n    addEntity(entity)\n    {\n        Object.defineProperty(entity, \"z\",\n        {\n            set: (value) =>\n            {\n                entity._z = value;\n                this.entitiesNeedSorting = true;\n            },\n            get: () => { return entity._z; }\n        });\n        entity._z = this.entities.length > 0 ? this.entities[this.entities.length - 1].z + 1 : 0;\n\n        this.entities.push(entity);\n    }\n\n    removeEntity(entity)\n    {\n        entity._remove = true;\n        this.entitiesNeedRemoval = true;\n    }\n\n    updateEntities(deltaTime)\n    {\n        this.entities.forEach(entity =>\n        {\n            if (entity.update !== undefined) { entity.update(deltaTime); }\n        });\n\n        if (this.entitiesNeedRemoval)\n        {\n            this.entities = this.entities.filter(entity => entity._remove !== true);\n            this.entitiesNeedRemoval = false;\n        }\n    }\n\n    renderEntities()\n    {\n        this.entities.forEach(entity =>\n        {\n            if (entity.render !== undefined) { entity.render(); }\n        });\n    }\n\n    sortEntities()\n    {\n        if (this.entitiesNeedSorting)\n        {\n            // Higher values update/render later than lower values\n            this.entities.sort((entity1, entity2) => entity1.z - entity2.z);\n            this.entitiesNeedSorting = false;\n        }\n    }\n\n    clearAllEntities()\n    {\n        this.entities = [];\n    }\n\n    //////////////////////////\n    //----- RENDERING ------//\n    //////////////////////////\n\n    drawSprite(params)\n    {\n        // Assumes name, x, and y are defined in params\n        let image = this.getAsset(params.name);\n        let angle = params.angle !== undefined ? params.angle : 0;\n        let width = params.xScale !== undefined ? image.width * params.xScale : image.width;\n        let height = params.yScale !== undefined ? image.height * params.yScale : image.height;\n\n        this.ctx.save();\n        this.ctx.translate(params.x, params.y);\n        this.ctx.rotate(angle * Math.PI/180);\n        this.ctx.drawImage(image, -width * 0.5, -height * 0.5, width, height);\n        this.ctx.restore();\n    }\n\n    drawText(params)\n    {\n        // Assumes text, x, and y are defined in params\n        let angle = params.angle !== undefined ? params.angle * Math.PI/180 : 0;\n        let fontName = params.fontName !== undefined ? params.fontName : \"Arial\";\n        let fontSize = params.fontSize !== undefined ? params.fontSize : 12;\n        let fontStyle = params.fontStyle !== undefined ? params.fontStyle : \"\";\n        let fillStyle = params.color !== undefined ? params.color : \"#FFF\";\n        let textAlign = params.textAlign !== undefined ? params.textAlign.toLowerCase() : \"left\";\n        let textBaseline = params.textBaseline !== undefined ? params.textBaseline.toLowerCase() : \"bottom\";\n\n        this.ctx.save();\n        this.ctx.translate(params.x, params.y);\n        this.ctx.rotate(angle);\n        this.ctx.font = `${fontStyle} ${fontSize}px ${fontName}`;\n        this.ctx.fillStyle = fillStyle;\n        this.ctx.textAlign = textAlign;\n        this.ctx.textBaseline = textBaseline;\n        this.ctx.fillText(params.text, 0, 0);\n        this.ctx.restore();\n    }\n\n    ///////////////////////////\n    //-------- AUDIO --------//\n    ///////////////////////////\n\n    initAudio()\n    {\n        this.soundOn = true;\n\n        this.notes =\n        {\n            \"c\": 16.35,\n            \"c#\": 17.32,\n            \"d\": 18.35,\n            \"d#\": 19.45,\n            \"e\": 20.60,\n            \"f\": 21.83,\n            \"f#\": 23.12,\n            \"g\": 24.50,\n            \"g#\": 25.96,\n            \"a\": 27.50,\n            \"a#\": 29.14,\n            \"b\": 30.87,\n        }\n\n        window.addEventListener('click', () =>\n        {\n            this.createAudioContext();\n        });\n    }\n\n    createAudioContext()\n    {\n        if (!this.audioCtx)\n        {\n            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n\n            let bufferSize = 2 * this.audioCtx.sampleRate * 6;\n            this.noiseBuffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);\n            this.noiseOutput = this.noiseBuffer.getChannelData(0);\n            for (let i = 0; i < bufferSize; i++)\n            {\n                this.noiseOutput[i] = -1.0 + Math.random() * 2;\n            }\n        }\n        else\n        {\n            this.audioCtx.resume();\n        }\n    }\n\n    playAudio(name, loop)\n    {\n        if (!this.soundOn || !this.audioCtx)\n        {\n            return;\n        }\n\n        this.getAsset(name).loop = loop !== undefined ? loop : false;\n        this.getAsset(name).play();\n    }\n\n    stopAudio(name)\n    {\n        this.getAsset(name).pause();\n        this.getAsset(name).currentTime = 0;\n    }\n\n    playNote(note, octave, length, delay, type)\n    {\n        if (!this.soundOn || !this.audioCtx)\n        {\n            return;\n        }\n\n        let oscillator = this.audioCtx.createOscillator();\n        let noteFrequency = this.notes[note.toLowerCase()];\n        if (octave !== undefined)\n        {\n            noteFrequency *= Math.pow(2, octave);\n        }\n\n        oscillator.type = type !== undefined ? type : \"sine\";\n        oscillator.frequency.setValueAtTime(noteFrequency, this.audioCtx.currentTime);\n\n        if (length !== undefined)\n        {\n            length *= 2;\n        }\n\n        if (delay !== undefined)\n        {\n            delay *= 2;\n        }\n        \n        oscillator.connect(this.audioCtx.destination);\n        oscillator.start(this.audioCtx.currentTime + (delay !== undefined ? delay : 0));\n        oscillator.stop(this.audioCtx.currentTime + (delay !== undefined ? delay : 0) + (length !== undefined ? length : 0.2));\n    }\n\n    playNoise(length, delay)\n    {\n        if (!this.soundOn || !this.audioCtx)\n        {\n            return;\n        }\n\n        let whiteNoise = this.audioCtx.createBufferSource();\n        whiteNoise.buffer = this.noiseBuffer;\n        whiteNoise.loop = true;\n        whiteNoise.start(this.audioCtx.currentTime + (delay !== undefined ? delay : 0));\n        whiteNoise.stop(this.audioCtx.currentTime + (delay !== undefined ? delay : 0) + (length !== undefined ? length : 0.2));\n\n        whiteNoise.connect(this.audioCtx.destination);\n    }\n\n    ///////////////////////////\n    //-------- INPUT --------//\n    ///////////////////////////\n\n    initInput()\n    {\n        this.mousePos = {x: 0, y: 0};\n        this.mouseDelta = {x: 0, y: 0};\n        this.mouseLeftButton = false;\n        this.mouseRightButton = false;\n        this.mouseLeftButtonJustPressed = false;\n        this.mouseRightButtonJustPressed = false;\n\n        window.addEventListener(\"mousemove\", e =>\n        {\n            this.mouseDelta.x += e.movementX;\n            this.mouseDelta.y += e.movementY;\n\n            var rect = this.canvas.getBoundingClientRect();\n            this.mousePos = {x: e.clientX - rect.left, y: e.clientY - rect.top};\n        });\n\n        window.addEventListener(\"mousedown\", e =>\n        {\n            if (e.button === 0) { this.mouseLeftButton = true; this.mouseLeftButtonJustPressed = true; }\n            else if (e.button === 2) { this.mouseRightButton = true; this.mouseRightButtonJustPressed = true; }\n        });\n\n        window.addEventListener(\"mouseup\", e =>\n        {\n            if (e.button === 0) { this.mouseLeftButton = false; }\n            else if (e.button === 2) { this.mouseRightButton = false; }\n        });\n\n        window.addEventListener(\"touchstart\", this.touch2Mouse, true);\n        window.addEventListener(\"touchmove\", this.touch2Mouse, true);\n        window.addEventListener(\"touchend\", this.touch2Mouse, true);\n\n        this.keyToName =\n        {\n            \"a\": \"a\", \"b\": \"b\", \"c\": \"c\", \"d\": \"d\", \"e\": \"e\", \"f\": \"f\", \"g\": \"g\", \"h\": \"h\", \"i\": \"i\",\n            \"j\": \"j\", \"k\": \"k\", \"l\": \"l\", \"m\": \"m\", \"n\": \"n\", \"o\": \"o\", \"p\": \"p\", \"q\": \"q\", \"r\": \"r\",\n            \"s\": \"s\", \"t\": \"t\", \"u\": \"u\", \"v\": \"v\", \"w\": \"w\", \"x\": \"space\", \"y\": \"y\", \"z\": \"z\",\n            \"0\": \"zero\", \"1\": \"one\", \"2\": \"two\", \"3\": \"three\", \"4\": \"four\", \"5\": \"five\", \"6\": \"six\", \"7\": \"seven\", \"8\": \"eight\", \"9\": \"nine\",\n            \"arrowup\": \"up\", \"arrowdown\": \"down\", \"arrowleft\": \"left\", \"arrowright\": \"right\", \"x\": \"space\", \"escape\": \"escape\",\n            \"control\": \"ctrl\", \"shift\": \"shift\", \"alt\": \"alt\", \"tab\": \"tab\", \"enter\": \"enter\", \"backspace\": \"backspace\"\n        };\n\n        this.keys = {};\n        this.keysJustPressed = {};\n        Object.keys(this.keyToName).forEach(key => this.keys[key] = false);\n\n        window.addEventListener(\"keydown\", e =>\n        {\n            this.setKeyState(e, true);\n        });\n\n        window.addEventListener(\"keyup\", e =>\n        {\n            this.setKeyState(e, false);\n        });\n    }\n\n    touch2Mouse(e)\n    {\n        let theTouch = e.changedTouches[0];\n        let mouseEv;\n\n        switch(e.type)\n        {\n            case \"touchstart\": mouseEv=\"mousedown\"; break;  \n            case \"touchend\":   mouseEv=\"mouseup\"; break;\n            case \"touchmove\":  mouseEv=\"mousemove\"; break;\n            default: return;\n        }\n\n        let mouseEvent = document.createEvent(\"MouseEvent\");\n        mouseEvent.initMouseEvent(mouseEv, true, true, window, 1, theTouch.screenX, theTouch.screenY, theTouch.clientX, theTouch.clientY, false, false, false, false, 0, null);\n        theTouch.target.dispatchEvent(mouseEvent);\n\n        e.preventDefault();\n    }\n\n    setKeyState(event, isOn)\n    {\n        let keyCode = event.key.toLowerCase();\n        if (this.keyToName[keyCode] !== undefined)\n        {\n            let keyName = this.keyToName[keyCode];\n            this.keysJustPressed[keyName] = this.keys[keyName] === false || this.keys[keyName] === undefined;\n            this.keys[keyName] = isOn;\n            \n            // Hack: prevent arrow keys from scrolling the page\n            if (keyName === \"up\" || keyName === \"down\" || keyName === \"left\" || keyName === \"right\")\n            {\n                event.preventDefault();\n            }\n        }\n    }\n\n    postUpdateInput()\n    {\n        this.mouseDelta.x = 0.0;\n        this.mouseDelta.y = 0.0;\n        this.mouseLeftButtonJustPressed = false;\n        this.mouseRightButtonJustPressed = false;\n\n        Object.keys(this.keysJustPressed).forEach(key =>\n        {\n            this.keysJustPressed[key] = false;\n        });\n    }\n}\nvar screenWidth = 640;\nvar screenHeight = 480;\nvar screenScale = 1.0;\n\nvar aw = new Aw(screenWidth, screenHeight, screenScale, []);\naw.state = init;\n\nvar level;\nvar player;\nvar levelIdx = 0;\nvar endLevelTime = 0;\nvar lives = 5;\nvar difficultyMode = 0;\n\nfunction init(deltaTime)\n{\n    renderBackgroundSpeedLines(deltaTime);\n\n    if (aw.mouseLeftButtonJustPressed)\n    {\n        aw.state = mainMenu;\n        aw.mouseLeftButtonJustPressed = false;\n\n        aw.playNote(\"a\", 4, 0.05, 0.0);\n        aw.playNote(\"b\", 4, 0.05, 0.05);\n    }\n\n    // Click to play\n    aw.ctx.shadowBlur = 20;\n    aw.ctx.shadowColor = \"#08F\";\n    aw.drawText({text:\"CLICK TO PLAY\", x:screenWidth*0.5, y:screenHeight*0.5, fontSize:20, fontStyle:\"bold\", color:\"#08F\", textAlign:\"center\"});\n}",
      "status": "[1]<br><span style=\"font-size:8px\">3ms<span></span></span>",
      "output": "function init(deltaTime)\n{\n    renderBackgroundSpeedLines(deltaTime);\n\n    if (aw.mouseLeftButtonJustPressed)\n    {\n        aw.state = mainMenu;\n        aw.mouseLeftButtonJustPressed = false;\n\n        aw.playNote(\"a\", 4, 0.05, 0.0);\n        aw.playNote(\"b\", 4, 0.05, 0.05);\n    }\n\n    // Click to play\n    aw.ctx.shadowBlur = 20;\n    aw.ctx.shadowColor = \"#08F\";\n    aw.drawText({text:\"CLICK TO PLAY\", x:screenWidth*0.5, y:screenHeight*0.5, fontSize:20, fontStyle:\"bold\", color:\"#08F\", textAlign:\"center\"});\n} <br>",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}